<div align="center">
  <img src=".github/autosa_logo.png", width="200">
</div>

# AutoSA: Polyhedral-Based Systolic Array Auto-Compilation

This repository includes the code for AutoSA. **AutoSA** is an end-to-end systolic array compiler based on the polyhedral model. It takes algorithms in high-level programming languages (C) as inputs, performs polyhedral transformation and other architecture optimization to map algorithms to systolic array architecture. The generated designs are in HLS C.

The structure of this repo is as follows:
```

.
|-- README.md: this file
|-- src: directory for AutoSA source code
    |-- isl: directory for Integer Set Library (isl)
    |-- pet: directory for Polyhedral Extraction Tool (pet)
|-- autosa_config: directory for AutoSA configuration files
|-- autosa_scripts: directory for AutoSA scripts
|-- autosa_tests: directory for AutoSA test code
|-- autosa.tmp: directory for temporary file generated by AutoSA
    |-- output: directory for generated code by AutoSA
        |-- src: diretory for generated HLS C kernel code and OpenCL host code
        |-- latency_est: directory for metadata used for latency estimation of the generated design
        |-- resource_est: directory for metadata used for resource estimation of the generated design
    |-- optimizer: directory for intermediate files generated by AutoSA Optimizer
```

## Contents
1. [Latest Features](#latest-features)
2. [Prerequisites](#prerequisites)
3. [Getting Started](#getting-started)
   1. [Compilation](#compilation)
   2. [Use AutoSA to generate HLS code](#use-autosa-to-generate-hls-code)
   2. [More details about AutoSA](#more-details-about-autosa)
4. [Send Us Failure Cases and Feedback!](#send-us-failure-cases-and-feedback)
5. [Authors and Contributors](#authors-and-contributors)

## Latest Features


## Prerequisites
### PPCG
AutoSA is build upon PPCG 0.08.3 (source repository: http://repo.or.cz/ppcg.git).
Below are the requirements for installing PPCG:
- automake, autoconf, libtool
	(not needed when compiling a release)
- pkg-config (http://www.freedesktop.org/wiki/Software/pkg-config)
	(not needed when compiling a release using the included isl and pet)
- gmp (http://gmplib.org/)
- libyaml (http://pyyaml.org/wiki/LibYAML)
	(only needed if you want to compile the pet executable)
- LLVM/clang libraries, 2.9 or higher (http://clang.llvm.org/get_started.html)
	Unless you have some other reasons for wanting to use the svn version,
	it is best to install the latest release (3.9).
	For more details, see pet/README.

If you are installing on Ubuntu, then you can install the following packages:

automake autoconf libtool pkg-config libgmp3-dev libyaml-dev libclang-dev llvm

Note that you need at least version 3.2 of libclang-dev (ubuntu raring).
Older versions of this package did not include the required libraries.
If you are using an older version of ubuntu, then you need to compile and
install LLVM/clang from source.
### Others
+ Python3.6+ and corresponding `pip`

## Getting Started
### Compilation
```bash
./install.sh
```

### Use AutoSA to generate HLS code
1. Annotate the code region to be transformed to HLS C.

Insert a line containing 
```c
#pragma scop
```
before the fragment and add a line containing
```c
#pragma endscop
```
after the fragment.

2. Generate HLS C and OpenCL host code.

Run
```c
./autosa ./autosa_tests/mm/kernel.c --AutoSA-config=./autosa_config/autosa_config.json --target=autosa_hls_c --AutoSA-autosa --AutoSA-two-level-buffer --AutoSA-uram --isl-schedule-whole-component --AutoSA-output-dir=./autosa.tmp/output --AutoSA-simd-info=./autosa_tests/mm/simd_info.json
```
where `kernel.c` is the file containing the fragment. The generated code can be found in `autosa.tmp/output/src/kernel_host.cpp` and `autosa.tmp/output/src/kernel_kernel.cpp`. For detailed explaination of each AutoSA compilation option, please run
```c
./autosa --help
```
or refer to xxx.

### More details about AutoSA
The figure below depicts the overall compilation flow of AutoSA.

1. **Model extraction**: This step extracts the polyhedral model from the input C code.
2. **Scheduling**: This step leverages the [isl](http://isl.gforge.inria.fr/) scheduler to construct a new schedule using the extended Pluto algorithm.
3. **Legality check**: This step checks if the generated schedule is legal to be mapped to systolic arrays.
4. **Computation management**: This step constructs the PE arrays and optimizes the micro-architecture of PEs to improve the compute efficiency.
   1. **Space-time transformation**: This step applies the space-time transformation to transform programs to systolic arrays.
   2. **Array partitioning**: This step partitions the array into smaller sub-arrays.
   3. **Latency hiding**: This step tiles and permutes the parallel loops to the innermost to hide the pipeline latency.
   4. **SIMD vectorization**: This step vectorizes the computation inside PEs.
5. **Communication management**: This step generates and optimizes the I/O system for communication between PEs and the external memory.
6. **Code generation**: This step generates the HLS C code.
7. **Design space exploration (optional)**: This step searches for the best design (with the least latency) given the hardware constraints.

For step 4, AutoSA can apply the optimization in two modes: *auto* and *manual*. In the auto mode, AutoSA will proceed based on the pre-set policy. In the manual mode, AutoSA will dump out the optimization choices, take the user input, and apply the optimization based on the user specification. To switch between two different modes, modify the knobs in `autosa_config/autosa_config.json`.
For example, modify the content in `autosa_config/autosa_config.json` to:
```json
"array_part": {
  "enable": 1,
  "mode": "auto"
}
```
to enable the array partitioning and execute it in the auto mode.
Modify the content to:
```json
"array_part": {
  "enable": 1,
  "mode": "manual"
}
```
to execute this step in the manual mode.

Below we explain how to use AutoSA in manual mode in detail.

* __Space-time transformation__
In this step, multiple systolic arrays are generated for the input program. We will need to select one systolic array to proceed. We set this step to manual mode in the AutoSA configuration file. 
```json
"space_time": {  
  "mode": "manual"
}
```
Then run the command:
```c
./autosa ./autosa_tests/mm/kernel.c --AutoSA-config=./autosa_config/autosa_config.json --target=autosa_hls_c --AutoSA-autosa --AutoSA-two-level-buffer --AutoSA-uram --isl-schedule-whole-component --AutoSA-output-dir=./autosa.tmp/output --AutoSA-simd-info=./autosa_tests/mm/simd_info.json
```
AutoSA will generate a file `autosa.tmp/output/tuning.json` which includes guidance information for further optimization. In this example, we have the content below:
```json
"space_time": {
  "n_kernel": 6
}
```
This tells the user that there are 6 different systolic array candidates that are generated. We may select one of them to proceed. For example, we could select the fourth candidate which is a 2D systolic array with the data from matrix `A` transferred horizontally, and data from matrix `B` transferred vertically. Each PE computes one element of `C[i][j]` locally, which is drained out at last to the external memory. The architecture of this array is depicted below. To guide AutoSA to select this design, we will provide AutoSA with the new argument
```
--sa-sizes="{kernel[0]->space_time[3]}"
```
which tells AutoSA to select the fourth array (index starting from 0) during the sapce-time transformation.

* __Latency hiding__

## Send Us Failure Cases and Feedback!
AutoSA is open source for research purposes, and we would like to continously improve it! Please let us know if...

1. you find any bug in the AutoSA code.
2. you find any application that fails the compilation flow of AutoSA.
3. you know how to further help improve any part of the compiler.
4. etc.

## Authors and Contributors
AutoSA is currently maintained by [Jie Wang](http://cadlab.cs.ucla.edu/~jaywang/).
Besides, we gratefully acknowledge the authors of PPCG for developing and actively maintaining PPCG as an open-source project.

## Version History
+ [2020/5/15] Version 0.01 is released.
